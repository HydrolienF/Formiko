<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>fichier.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Formiko</a> &gt; <a href="index.source.html" class="el_package">fr.formiko.usuel</a> &gt; <span class="el_source">fichier.java</span></div><h1>fichier.java</h1><pre class="source lang-java linenums">package fr.formiko.usuel;

//def par défaut des fichiers depuis 0.79.5
import fr.formiko.usuel.read;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import fr.formiko.usuel.listes.GString;
import fr.formiko.usuel.types.str;

<span class="nc" id="L13">public class fichier{</span>

  // CONSTRUCTEUR -----------------------------------------------------------------

  // GET SET -----------------------------------------------------------------------

  // Fonctions propre -----------------------------------------------------------
  /**
  *make a liste of all .java file in the directory f.
  *@param f The directory were to search java file.
  *@version 1.13
  */
  public static GString listerLesFichiersDuRep(File f){
<span class="fc" id="L26">    GString gs = new GString();</span>
    //parcourir les dossiers puis les sous dossiers etc jusqu'a ce que tout les fichiers soit traité,
    //cad sous la forme rep+sousdossier1+sousdossier2+nomDu.java
<span class="fc bfc" id="L29" title="All 2 branches covered.">    if (f.isDirectory()){</span>
<span class="fc" id="L30">      File allF [] = f.listFiles();</span>
<span class="pc bpc" id="L31" title="1 of 4 branches missed.">      if (allF != null &amp;&amp; allF.length&gt;0) {</span>
<span class="fc bfc" id="L32" title="All 2 branches covered.">          for (File file : allF) {</span>
            try {
<span class="fc" id="L34">              gs.add(listerLesFichiersDuRep(file));</span>
<span class="pc" id="L35">            }catch (Exception e) {}</span>
          }
      }
<span class="pc bpc" id="L38" title="1 of 2 branches missed.">    }else if(f.isFile()){</span>
<span class="fc" id="L39">      gs.add(f.getPath());</span>
    }
<span class="fc" id="L41">    return gs;</span>
<span class="nc" id="L42">  }public static GString listerLesFichiersDuRep(String rep){return listerLesFichiersDuRep(new File(rep));}</span>


  /**
   *{@summary Delete a directory and all his content.}&lt;br&gt;
   *@version 1.13
   */
  public static boolean deleteDirectory(File directoryToBeDeleted) {
<span class="pc bpc" id="L50" title="1 of 2 branches missed.">    if(directoryToBeDeleted==null){return false;}</span>
<span class="fc" id="L51">    File allF [] = directoryToBeDeleted.listFiles();</span>
    //on demande a tout les sous répertoires de ce surppimer.
<span class="fc bfc" id="L53" title="All 2 branches covered.">    if (allF != null) {</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">        for (File file : allF) {</span>
<span class="fc" id="L55">            deleteDirectory(file);</span>
        }
    }
    //on traite le fichier.
<span class="fc" id="L59">    return directoryToBeDeleted.delete();</span>
<span class="pc" id="L60">  }public static boolean deleteDirectory(String s){try {return deleteDirectory(new File(str.sToDirectoryName(s)));}catch (Exception e){return false;}}</span>

  public static void affichageDesLecteurALaRacine (File f){
<span class="nc" id="L63">    System.out.println(&quot;Affichage des lecteurs à la racine du PC : &quot;);</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">    for(File file : f.listRoots()){</span>
<span class="nc" id="L65">      System.out.println(file.getAbsolutePath());</span>
      try {
<span class="nc" id="L67">        int i = 1;</span>
        //On parcourt la liste des fichiers et répertoires
<span class="nc bnc" id="L69" title="All 2 branches missed.">        for(File nom : file.listFiles()){</span>
          //S'il s'agit d'un dossier, on ajoute un &quot;/&quot;
<span class="nc bnc" id="L71" title="All 2 branches missed.">          System.out.print(&quot;\t\t&quot; + ((nom.isDirectory()) ? nom.getName()+&quot;/&quot; : nom.getName()));</span>

<span class="nc bnc" id="L73" title="All 2 branches missed.">          if((i%4) == 0){</span>
<span class="nc" id="L74">            System.out.print(&quot;\n&quot;);</span>
          }
<span class="nc" id="L76">          i++;</span>
        }
<span class="nc" id="L78">        System.out.println(&quot;\n&quot;);</span>
<span class="nc" id="L79">      } catch (NullPointerException e) {</span>
        //L'instruction peut générer une NullPointerException
        //s'il n'y a pas de sous-fichier !
<span class="nc" id="L82">      }</span>
    }
<span class="nc" id="L84">  }</span>
  public static void fichierCiblePeuAvoirCeNom(String nom) {
<span class="nc" id="L86">    File f = new File(nom);</span>
    //if (f.exists()) { throw new FichierDejaPresentException (nom);}
<span class="nc" id="L88">  }</span>
  public static void copierUnFichier(String nomDuFichierACopier){
<span class="nc" id="L90">    String nomDuFichierCible = read.getString(&quot;Nom du nouveau fichier&quot;,&quot;Copie de &quot; + nomDuFichierACopier);</span>
<span class="nc" id="L91">    copierUnFichier(nomDuFichierACopier, nomDuFichierCible);</span>
<span class="nc" id="L92">  }</span>
  public static void copierUnFichier(String nomDuFichierACopier, String nomDuFichierCible){
    /*try {
      fichierCiblePeuAvoirCeNom(nomDuFichierCible);
    } catch (FichierDejaPresentException e){
      e.printStackTrace();
    }*/
    /*if (f.exists()){ // permet d'éviter : qu'un fichier soit écrabouiller et que le fichier x soit copié dans le fichier x.
      erreur.erreur(&quot;Le nom du nouveau fichier existe déjà ! Il ne faudrait pas l'écraser !&quot;,&quot;fichier.copierUnFichier&quot;,true);
    }*/
    // Nous déclarons nos objets en dehors du bloc try/catch
<span class="nc" id="L103">    FileInputStream fis = null;</span>
<span class="nc" id="L104">    FileOutputStream fos = null;</span>

    try {
       // On instancie nos objets :
       // fis va lire le fichier
       // fos va écrire dans le nouveau !
<span class="nc" id="L110">       fis = new FileInputStream(new File(nomDuFichierACopier));</span>
<span class="nc" id="L111">       fos = new FileOutputStream(new File(nomDuFichierCible));</span>

       // On crée un tableau de byte pour indiquer le nombre de bytes lus à chaque tour de boucle
<span class="nc" id="L114">       byte[] buf = new byte[8];</span>

       // On crée une variable de type int pour y affecter le résultat de
       // la lecture (Vaut -1 quand c'est fini)
<span class="nc" id="L118">       int n = 0;</span>

       // Tant que l'affectation dans la variable est possible, on boucle
       // Lorsque la lecture du fichier est terminée l'affectation n'est
       // plus possible ! On sort donc de la boucle
<span class="nc bnc" id="L123" title="All 2 branches missed.">       while ((n = fis.read(buf)) &gt;= 0) {</span>
          // On écrit dans notre 2a fichier avec l'objet adéquat
<span class="nc" id="L125">          fos.write(buf);</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">          if (debug.getAffLesEtapesDeRésolution()){</span>
          // On affiche ce qu'a lu notre boucle au format byte et au format char
<span class="nc bnc" id="L128" title="All 2 branches missed.">          for (byte bit : buf) {</span>
<span class="nc" id="L129">            System.out.print(&quot;\t&quot; + bit + &quot;(&quot; + (char) bit + &quot;)&quot;);</span>
          }
<span class="nc" id="L131">          System.out.println(&quot;&quot;);</span>
          }
          //Nous réinitialisons le buffer à vide
          //au cas où les derniers byte lus ne soient pas un multiple de 8
          //Ceci permet d'avoir un buffer vierge à chaque lecture et ne pas avoir de doublon en fin de fichier
<span class="nc" id="L136">          buf = new byte[8];</span>
       }
<span class="nc" id="L138">       debug.débogage(&quot;Copie terminée !&quot;);</span>

<span class="nc" id="L140">    } catch (FileNotFoundException e) {</span>
       // Cette exception est levée si l'objet FileInputStream ne trouve aucun fichier
<span class="nc" id="L142">       e.printStackTrace();</span>
<span class="nc" id="L143">    } catch (IOException e) {</span>
       // Celle-ci se produit lors d'une erreur d'écriture ou de lecture
<span class="nc" id="L145">       e.printStackTrace();</span>
    } finally {
       // On ferme nos flux de données dans un bloc finally pour s'assurer
       // que ces instructions seront exécutées dans tous les cas même si
       // une exception est levée !
       try {
<span class="nc bnc" id="L151" title="All 2 branches missed.">          if (fis != null)</span>
<span class="nc" id="L152">             fis.close();</span>
<span class="nc" id="L153">       } catch (IOException e) {</span>
<span class="nc" id="L154">          e.printStackTrace();</span>
<span class="nc" id="L155">       }</span>

       try {
<span class="nc bnc" id="L158" title="All 2 branches missed.">          if (fos != null)</span>
<span class="nc" id="L159">             fos.close();</span>
<span class="nc" id="L160">       } catch (IOException e) {</span>
<span class="nc" id="L161">          e.printStackTrace();</span>
<span class="nc" id="L162">       }</span>
    }
<span class="nc" id="L164">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>